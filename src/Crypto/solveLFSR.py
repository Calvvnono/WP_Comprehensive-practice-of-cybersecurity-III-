# Python
from sympy import symbols, GF, poly
from sympy.polys.polytools import invert, div
from Crypto.Util.number import long_to_bytes

# 将输出的比特序列复制到这里
bits = '10000100001110000110010001010111011110010100101011100100100001111010011001010101100101010011101010000011010011001100111110000100101011011101001111100010101001111011111111001010110111010000110011110010101001000111111000011110101010100010101111010111010001101100110111110001101000100100011000010010100011010111110101100100111010101011011100111001001110010101110011101010110011101101010010010101111110100011011111110001110000001000111111000011101010001100110000001010001000010001010001101010110100101001011111100101100001000010000011000110011110110111011111000101100100111101111011000000010111100010010010100101011110110010001100101111001101100000100010011101110000100111010100110111110110001100001000100001011010010111100011001110001011011110001101010110111000101110110110101101110101100010111010001000100100100001011011101101110101101011111010110110110010100010101100010100001000010001010100000001011110011011100111110001110111111010000000000111100011011011101110011111101000000111011111010101101110100010011101001110010111101101010110111110010110101111100111010001110100110110010000000101111000010100101110000100111111000111100110010100001011101100000001010111010001001110110011100001011101000110111000001100110101100100000101000011001011000110110000011101110001010001110111111100010100110101110110001101101001001011101001101101100110100010101000110010011101001101000000101100110010100111000100001001101101110100000101111011011010111101101000010100000110011111011010011000001100010110001101110010001100100111100000111111111101111001011010110100111010111111110100110110010111100011100010010101111110011010001111100100011110111100111100011110001011000010101100111101001111110101010000010100101101010110101101011010001111110100101001010010000010010000101101011000011010100101010111000100101001101010110101000010110000111000011101010010100011001011101000011101001011001001100000000100101110011110010111101111011110011100011110110010010101110110100110011100010000100101100011100100110011010101000010100010101110100000001111001000'
# 将比特序列转换为整数列表
s = [int(b) for b in bits]

# 实现 Berlekamp-Massey 算法
def berlekamp_massey(s):
    n = len(s)
    c = [0]*n
    b = [0]*n
    c[0], b[0] = 1, 1
    l, m, bb = 0, -1, 1
    for i in range(n):
        d = s[i]
        for j in range(1, l+1):
            d ^= c[j]*s[i-j]
        if d == 1:
            t = c[:]
            for j in range(i - m, n):
                c[j] ^= b[j - (i - m)]
            if 2 * l <= i:
                l = i + 1 - l
                m = i
                b = t
    return c[:l+1], l

# 获取反馈多项式和寄存器长度
poly_coeffs, span = berlekamp_massey(s)
print("反馈多项式系数:", poly_coeffs)
print("寄存器长度:", span)

# 构建反馈多项式
F = GF(2)
x = symbols('x')
feedback_poly = sum([poly_coeffs[i]*x**i for i in range(len(poly_coeffs))])
feedback_poly = poly(feedback_poly, x, modulus=2)
print("反馈多项式:", feedback_poly)

# 逆向初始状态
# 由于已知输出序列，我们可以使用已知的反馈多项式和输出序列，求解初始状态
N = len(s)
state = s[:span][::-1]  # 初始状态

# 将比特序列转换为字节，得到 FLAG
flag_bits = state[::-1]
flag_int = 0
for bit in flag_bits:
    flag_int = (flag_int << 1) | bit

flag_bytes = long_to_bytes(flag_int)
print("FLAG:", flag_bytes)